# Task №5 (`WW_io`)

Реализуйте приложение `./lab_05`, которое умеет читать упорядоченный список точек из определённого
файла текстового или бинарного формата (описаны ниже) и выполнять следующие действия.

1. Сохранять прочитанные точки в другой файл в текстовом или бинарном формате.
2. Выводить все точки на экран в заданном в качестве параметра командной строки формате.
3. Выводить на экран количество точек.

Гарантируется, что координаты не превосходят 5'000'000 по модулю (пять миллионов).

### Формат текстовых файлов
Текстовой файл, содержащий `N` точек, состоит из `N` строк.
Каждая строка заканчивается символом перевода строки.
В каждой строчке содержится ровно два целых числа, разделённых ровно одним пробелом:
`x`-координата точки и `y`-координата точки.
Другие символы в файле отсутствуют, лидирующие нули отсутствуют.

Помните, что стандартные функции ввода-вывода корректно заменяют `\n`
на нужный конкретной ОС перевод строки, не надо это обрабатывать руками.

### Формат бинарных файлов
Бинарный файл, содержащий `N` точек, состоит из `6N` байт.
Каждая точка хранится как 6 подряд идущих байт: три байта хранят координату
`x`, а следующие три байта хранят координату `y`.

Неотрицательные число хранятся побайтово: от младших байтов к старшим.
Например, число 1000 должно храниться как три последовательных байта со
значениями `232, 3, 0`.

### Консольное приложение
Приложение запускается следующей командой:

```
./lab_05 (loadtext | loadbin) <infile> <action...>
```

Здесь используются следующие параметры.

* `(loadtext | loadbin)` определяет вид входного файла: `loadtext` для текстового, `loadbin` для двоичного. Один параметр.
* `<infile>` — относительный путь к входному файлу, который хранит точки. Один параметр.
* `<action...>` — одна операция, которую нужно выполнить над точками.
  Задаётся одним или несколькими параметрами.
  * `(savetext | savebin) <outfile>` — сохранить считанные точки в файл `<outfile>` в текстовом (`savetext`) или бинарном (`savebin`) формате;
  * `print <fmt>` — вывести все точки на экран, использовать printf-строчку `<fmt>` для вывода.
    Должно встречаться ровно два спецификатора: первый `%d` соответствует `x`-координате, второй — `y`-координате;
    Разделители, не указанные в `<fmt>`, добавляться не должны (например, пробелы).
    После вывода ваша программа должна вывести перевод строки.
  * `count` — вывести на экран количество точек и перевод строки.

Гарантируется, что входной файл соответствует формату.

Пример работы:

```
$ cat test.txt
1 2
4 3
5 5
$ ./lab_05 loadtext test.txt savetext out.txt
$ cat out.txt
1 2
4 3
5 5
$ ./lab_05 loadtext test.txt count
3
$ ./lab_05 loadtext test.txt print "[%d, %d] "
[1, 2] [4, 3] [5, 5] 
$ ./lab_05 loadtext test.txt print "[%d, %d]"
[1, 2][4, 3][5, 5]
$ ./lab_05 loadtext test.txt savebin out.bin
$ hexdump -C out.bin
00000000  01 00 00 02 00 00 04 00  00 03 00 00 05 00 00 05  |................|
00000010  00 00                                             |..|
00000012
$ ./lab_05 loadbin out.bin print "%d %d "
1 2 4 3 5 5 
```

### Реализация операций `print` и `count`
Операции `print` и `count` требуется реализовать, используя функцию `apply`.
Использовать `get_length` для реализации `count` в этом задании запрещается.

Функция `apply` выполняет некоторую унарную операцию на каждом элементе списка
(например, вывод на экран).
Она должна быть реализована в файлах `clist.h` и `clist.c` и работать для списков
из элементов произвольного типа:

```C++
void apply(intrusive_list *list, void (*op)(intrusive_node *node, void *data), void *data);
```

Здесь параметр `data` функция `apply` не использует напрямую, а передаёт в функцию `op` как дополнительный параметр.
Это нужно, чтобы можно было не меняя сигнатуру `apply` передавать в `op`, помимо элемента списка, произвольные параметры.
Также `data` можно использовать для получения из `op` произвольных значений.


