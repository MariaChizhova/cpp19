# Task №4 (`WW_mergesort`)

1. [Обобщённая сортировка](#обобщённая-сортировка)
1. [Консольное приложение](#консольное-приложение)
1. [Бонусное задание](#бонусное-задание)

Реализуйте алгоритм сортровки слиянием(merge sort), способный работать для произвольных типов данных в языке Си.
Реализация должна находиться в файлах `mergesort.h` и `mergesort.c`.

В файле `main.c` реализовано консольное приложение, которое сортирует
переданные в качестве аргументов командной строки данные и печатает отсортированный массив.

### Обобщённая сортировка
Предполагается, что каждый элемент занимает фиксированное количество байт в памяти,
а сами элементы для сортировки лежат в массиве подряд.

Требуемая сигнатура единственной функции в `mergesort.h`:

```
void mergesort(void *array, size_t elements, size_t element_size, int (*comparator)(const void*, const void*));
```

Ей передаются следующие параметры:

* `array` — указатель на начало массива. Так как тип данных неизвестен, это указатель на `void`.
* `elements` — количество элементов в массиве.
* `element_size` — размер одного элемента в массиве.
* `comparator` — указатель на функцию, которая умеет сравнивать два элемента по константным указателям на них.
  Эта функция знает тип данных, который ей передают, однако её параметры всё равно
  имеют тип `void*`, потому что его надо зафиксировать в файле `mergesort.h`.
  `comparator(a, b)` ведёт себя аналогично `strcmp`: возвращает ноль, если `a` и `b`
  эквивалентны с точки зрения сортировки,
  отрицательное число, если `a` должно стоять до `b` в отсортированном массиве,
  и положительное число иначе.

Если какой-нибудь из аргументов некорректен (например, `comparator` не задаёт
отношение полного порядка на классах эквивалентности элементов), то поведение,
как обычно, не определено.

Пример вызова:

```
// int greater than comparator
int int_gt_comparator(const void *a, const void *b) {
    return *(int*)b - *(int*)a;  // Сортировка массива по убыванию.
}
// ...
int data[] = { 3, 1, 2 };
mergesort(data, sizeof data / sizeof data[0], sizeof data[0], int_gt_comparator);
```

### Консольное приложение
В качестве аргументов командной строки (смотри параметры `argc` и `argv` у `main()`) приложению передаются:

1. Аргумент №1: тип элементов, которые требуется отсортировать.
   Принимает одно из значений: `int`, `char`, `str`.
2. Аргумент №2 и последующие: элементы массива, который требуется отсортировать.
   Гарантируется, что все числа помещаются в `int` даже после умножения на три.
   Гарантируется, что внутри строчек и символов используются только ASCII-символы с кодами от 32 до 127, включительно.

Аргументы всегда корректны.
Обратите внимание, что массив может быть пустым, в этом случае аргумент №2 отсутствует.

Приложение должно вывести те же элементы массива, отсортированные по неубыванию, разделённые ровно одним пробелом, на одной строчке.
Какие-либо ещё символы выводить запрещается.
Числа сравниваются по значению, символы — по ASCII-коду, строчки — лексикографически.

Пример работы:

| Команда запуска                    | Вывод                 |
|:---                                |:---                   |
| `./lab_04 int -1 0 2 0 3`          | `-1 0 0 2 3`          |
| `./lab_04 char z y x`              | `x y z`               |
| `./lab_04 str foo bar bazooka baz` | `bar baz bazooka foo` |

### Бонусное задание

Как говорилось выше, внутри функции `mergesort` может возникнуть ошибка при выделении памяти (`malloc` вернёт `NULL`).
Вместо обрушения программы через `assert` внутри функции, аккуратно обработайте эту ошибку.

1. Измените функцию `mergesort`, чтобы она возвращала `int`:
   ```
   int mergesort(void *array, size_t elements, size_t element_size, int (*comparator)(const void*, const void*));
   ```
   Как это часто делается в Си, верните `0` в случае успеха и `-1` в случае провала (из-за ошибки выделения памяти).
1. Измените все места вызова функции `mergesort` для корректной обработки возвращаемого значения.
1. При возникновении данной ошибки программа должна вывести единственную строчку `Error: memory allocation failed.` и завершить работу с кодом возврата 1.
   Делать эти действия разрешается *только* в функции `main`.
1. Даже при ошибке выделения памяти, вся успешно выделенная память должна быть освобождена.
